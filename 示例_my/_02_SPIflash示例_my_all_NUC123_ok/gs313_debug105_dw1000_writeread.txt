

iputs("task--01.\r\n");  //--zz debug

uartdecode( ival, "  ival: " );
uartdecodeH( ival, "  ival: " );

=============


flow：

SPI1初始化:    main  --> spiFlashInit  --> DrvSPI_Init   

SPI1写数据:   main  -->  dwt_writetodevice  -->  writetospi  -->  spiSendWord  -->  itemp = SPI2->RX[0]

SPI1读数据:   main  -->  dwt_readfromdevice  -->   readfromspi    -->  spiSendWord  -->  ivalue = SPI2->RX[0]



=========SPI1时钟设置======================

注意：  SPI1的时钟源可选PLL和HCLK  (当前的项目中，一般 HCLK = PLL/1 )
           SPI1时钟源可由CNTRL2.31 和CLKSEL1.5来选择
           当前使用的是HCLK / ( (n+1) *2 )


补充： mode0  就是时钟线空闲为低电平， 第1个时钟沿接收，第2个时钟沿发送

-------------------------------SPI1初始化-------------------------------------

main()
       spiFlashInit()


----------------------------SPI1写数据-------------------------------------------------

main()

   while      

      ibuf2[0]=0x08;
      ibuf2[1]=0x08;
      ibuf2[2]=0x08;
      ibuf2[3]=0x08;
      dwt_writetodevice(0x03,0,4,ibuf2);     //往reg03中写入4个字节  （dw1000）



----------------------------SPI1读取数据---------------------------------------------


main()

   while      

       dwt_readfromdevice(0x03,0,4,ibuf);   //从reg03中读取4个字节的数据  （dw1000）
      
       uartdecodeH(ibuf[0],"  ibuf0: ");
       uartdecodeH(ibuf[1],"  ibuf1: ");
       uartdecodeH(ibuf[2],"  ibuf2: ");
       uartdecodeH(ibuf[3],"  ibuf3: ");



===============================================================
  
void spiFlashInit()     //spi2

    GPIO_SPI2_SS0_PB4();              //GPB_MFP.4=0, ALT_MFP.15=1 ,  用pb4 做spi2的ss0
    GPIO_SPI2_CLK_PB5();             //GPB_MFP.5=1, ALT_MFP.18=1 ,  用pb5 做spi2的clk
    GPIO_SPI2_MOSI0_PB6();         //GPB_MFP.6=1, ALT_MFP.17=1 ,  用pb5 做spi2的MO
    GPIO_SPI2_MISO0_PB7();         //GPB_MFP.7=1, ALT_MFP.16=1 ,  用pb6 做spi2的MI
   
    SPI_SET_SS(SPI2, SPI_SS_LOW_TRIGGER, SPI_SW_SS);     //SPI2_SSR.2=0, SPI2_SSR.3=0     //--   片选信号为低电平，  手动片选
    SPI_SET_SS0(SPI2);   //SPI2_SSR.0=1     //--CS0为有效（手动片的情况下，CS0为手动片选） 
                                                              (注意： 如果SPI2_SSR.1-0=11， 则CS0,CS1都有效，可控制2个相同的从机，一般可切换CS0,CS1有效)

    DrvSPI_Init(SPI2, SPI_MASTER, SPI_TYPE0, 32);   //使能 SPI1 clock，spi复位，设置spi传输32位，设置 spi为主模式， 模式0：空闲 clk为低电平，clk下降沿发送数据，clk上升沿接收数据 
                                                                        注意： 在spi连25p80是SP_TYPE2（下降沿发送，上升沿接收，空闲时clk为高电平），
                                                                                  而在spi连dw1000时是SPI_TYPE0（下降沿发送，上升沿接收，空闲时clk为低电平）

    SPI_SET_MSB_FIRST(SPI2);         //SPI2_CNTRL.10=0    //--MSB优先
    SPI_DISABLE_REORDER(SPI2);    //SPI2_CNTRL.19=0    //-- 禁用字节重排序功能  （待理解）
    SPI_ENABLE_BCN(SPI2);            //SPI2_CNTRL2.31=0    //--时钟源为sysclock，SPI 串行时钟除以 (DIVIDER1+1)*2 ，细节请参考SPI_DIVIDER寄存器
   
    SPI_SET_DIVIDER(SPI2, 1);        //DIVIDER.0-7=00000001 (n)，   spiclk=sysckl/ ( (n+1)*2)  = 72  /4 = 18 MHZ    


---

  SPI_MASTER:  0<<18
  SPI_TYPE0:     0x004

  int32_t DrvSPI_Init( SPI2, SPI_MASTER, SPI_TYPE0, 32)

       APBCLK_ENABLE(CLK_SPI2);               //APBCLK.14=1,  使能 SPI2 clock  
       SYS_RESET_IP2(SYS_RST_SPI2);           //IPRSTC2 | =（1<<14）;  IPRSTC2 & =~（1<<14）;  //1--SPI2复位，0--正常

       if(i32BitLength == 32)
           i32BitLength = 0;
    
      SPI_SET_TX_BIT_LEN(SPI2, 32 );             //SPI2_CNTRL.7-3=00000, CNTRL,7-3=x        //--设置spi传输bit位数量
      SPI_SET_MODE(SPI2, SPI_MASTER);       //SPI2_CNTRL.18=0              //--设置 spi为主模式

      SPI_Waveform(SPI2, SPI_TYPE0);           //SPI2_CNTRL.11-2-1=010    //空闲时clk为低电平， clk下降沿发送数据，clk上升沿接收数据  （待验证）
    

---------------------

//计算得出spi从机的地址  （简化操作，偏移量为0，直接取寄存器地址作为地址）
void dwt_writetodevice( u16 recordNumber, u16 index, u32 length, const u8 *buffer )
 
    u8 header[3] ;  
    int   cnt = 0;  

    if (index == 0)  //偏移量为0
        header[cnt++] = 0x80 | recordNumber ;  

    else    //偏移量大于0
        header[cnt++] = 0xC0 | recordNumber ; 
        if (index <= 127)  
            header[cnt++] = (u8)index ; 
        else
            header[cnt++] = 0x80 | (u8)(index) ;  
            header[cnt++] =  (u8) (index >> 7) ;  
   
    writetospi(cnt,header,length,buffer);
 

---

//往spi从机的寄存器里写入数据
u16 writetospi( u16 headerLength, const u8 *headerBuffer, u32 bodylength, const u8 *bodyBuffer)

     u16 i=0;
     volatile u8 itemp=0;
    
     SPI_CLR_SS0(SPI2);                           // SPI2_SSR.0=0           //取消片选CS0 
     SPI_DISABLE_REORDER(SPI2);           // SPI2_CNTRL.19=0     //--禁用字节重排序功能
     SPI_SET_SS0(SPI2);                           //SPI2_SSR.0=1           //使能片选CS0 

     for(i=0; i<headerLength; i++)               //写入spi地址
         spiSendWord( headerBuffer[i], 8 );    //写入数据, 数据格式为8位
         //itemp = SPI2->RX[0];                       //读取数据    --空操作 ，可去掉 

    for(i=0; i<bodylength; i++)                //写入spi数据
         spiSendWord(bodyBuffer[i],8);      //写入数据, 数据格式为8位
         //itemp = SPI2->RX[0];                   //读取数据    --空操作，可去掉    

    SPI_CLR_SS0(SPI2);                         // SPI2_SSR.0=0           //取消片选CS0        

----

//往spi的缓冲区TX[0]写数据
void spiSendWord(u32 ulData, 8 )

    SPI_SET_TX_BIT_LEN(SPI2, 8 );      //SPI2_CNTRL.7-3=00000, CNTRL,7-3=x        //--设置spi传输bit位数量
    SPI_WRITE_TX0(SPI2, ulData);      //SPI2_TX[0] = ulData             //--把数据写入spi发送寄存器中                    
    SPI_SET_GO(SPI2);                      //SPI2_CNTRL.0=1                  //--开始spi数据传输 （发送更贴切一点）
    while(SPI_IS_BUSY(SPI2) != 0);     //--循环直到CNTRL.0=0 ，传输完成


----------------------

//计算得出spi从机的地址    （简化操作，偏移量为0，直接取寄存器地址作为地址）
void dwt_readfromdevice( u16 recordNumber, u16 index, u32 length, u8 *buffer )

    u8 header[3] ;  
    int cnt = 0;  

    if (index == 0)    //偏移量为0
        header[cnt++] = (u8) recordNumber ;  

    else   //偏移量大于0
        header[cnt++] = (u8)(0x40 | recordNumber) ; 
        if (index <= 127)  
            header[cnt++] = (u8) index ;  
        else
            header[cnt++] = 0x80 | (u8)(index) ; 
            header[cnt++] =  (u8) (index >> 7) ;  

    readfromspi(cnt, header, length, buffer);   


---


//从spi从机的寄存器里读取数据
int readfromspi(u16 headerLength, const u8 *headerBuffer, u32 readlength, u8 *readBuffer)

     SPI_CLR_SS0(SPI2);                           // SPI2_SSR.0=0           //取消片选CS0 
     SPI_DISABLE_REORDER(SPI2);           // SPI2_CNTRL.19=0     //--禁用字节重排序功能
     SPI_SET_SS0(SPI2);                           //SPI2_SSR.0=1           //使能片选CS0     

    //写入spi地址
    for(i=0; i<headerLength; i++)                 
        spiSendWord(headerBuffer[i],8);     //写入数据, 数据格式为8位  
        //readBuffer[0] = SPI2->RX[0];        //读取数据    --空操作 ，可去掉 
    
    SPI_ENABLE_REORDER(SPI2);            //CNTRL.19=1     //--使能字节重排序功能

    //读取spi数据
    for(i=0; i<readlength; i++)
        spiSendWord(0xff,8);                  //写入数据, 数据格式为8位  
        readBuffer[i] = SPI2->RX[0];       //读取交换来的spi数据   

    SPI_CLR_SS0(SPI2);                        // SPI2_SSR.0=0           //取消片选CS0 
 









   